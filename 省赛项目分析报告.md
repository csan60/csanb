# CST2024嵌入式分赛省赛项目完整分析报告

## 📋 项目概述

这是一个**温度控制器系统测试项目**，针对被测软件`SensorControl.exe`进行全面的功能、接口和性能测试。

### 被测系统功能
温度控制器通过以下方式实现恒温控制：
- 从温度传感器读取当前温度
- 根据设定温度与当前温度的差值，通过PID算法计算输出
- 控制加热棒输出电压（加热）
- 控制散热风扇开关（散热）
- 以1.2秒为周期循环执行

---

## 🏗️ 项目结构详解

```
省赛/
├── 被测件/
│   ├── SensorControl.exe              # 被测温度控制器软件
│   ├── Newtonsoft.Json.dll           # 依赖库
│   └── IPAddressControlLib.dll       # 依赖库
├── project/
│   ├── index.prj                      # 项目索引文件
│   ├── 仿真环境.env                   # 仿真环境配置
│   ├── 协议/                          # 通信协议定义
│   │   ├── P_Sensor.prot             # 温度传感器协议
│   │   ├── P_Heater.prot             # 加热棒协议
│   │   └── P_Fan.prot                # 散热风扇协议
│   ├── 测试脚本/                      # Lua测试脚本
│   │   ├── 01_温度采集处理.lua
│   │   ├── 02_接口_加热棒输出.lua
│   │   ├── 03_散热风散输出.lua
│   │   ├── 04_接口温度传感器输入.lua
│   │   ├── 05_性能_温控稳定时间性能需求_1.lua
│   │   ├── 06_系统循环控制.lua
│   │   ├── 07_加热棒输出.lua
│   │   ├── 08_接口散热风扇输出.lua
│   │   ├── 11_测试1边界值测试.lua
│   │   ├── 12_测试2.lua
│   │   └── 13_测试3.lua
│   ├── 测试数据/                      # YAML测试数据
│   │   ├── 01_温度采集处理.yml
│   │   └── 03_散热风散输出.yml
│   └── 执行配置/                      # 测试执行配置
│       ├── 01_温度采集处理.run
│       ├── 02_接口_加热棒输出.run
│       └── ... (11个.run配置文件)
├── CST2024嵌入式分赛--省赛--需求文档.pdf
├── CST2024嵌入式分赛--省赛--测试要求.pdf
├── CST2024嵌入式分赛--省赛--评分规则.pdf
├── CST2024嵌入式分赛--问题报告模板.xlsx
└── 覆盖率得分.png
```

---

## 📡 通信协议设计

### 1. 温度传感器协议 (P_Sensor)
**用途**: 测试脚本发送温度数据给被测系统

| 字段 | 类型 | 值/计算方式 | 说明 |
|------|------|------------|------|
| header | uint16 (大端) | 0xFFFA | 包头 |
| datatype1 | uint8 | 0x01 | 数据类型1 |
| datatype2 | uint8 | 0x10 | 数据类型2 |
| dataLen | uint8 | 0x04 | 数据长度（4字节） |
| temprature | float (小端) | 可变 | 温度值（-20~50℃） |
| check | uint16 (小端) | SUM_8_O16校验 | 校验和（从datatype1到temprature） |
| tail | uint8 | 0x0F | 包尾 |

**协议总长度**: 11字节

---

### 2. 加热棒协议 (P_Heater)
**用途**: 被测系统输出加热棒控制指令

| 字段 | 类型 | 值/计算方式 | 说明 |
|------|------|------------|------|
| header | uint16 (大端) | 0xFFFA | 包头 |
| datatype1 | uint8 | 0x02 | 数据类型1 |
| datatype2 | uint8 | 0x11 | 数据类型2 |
| datalen | uint8 | 0x04 | 数据长度（4字节） |
| voltage | float (小端) | 可变 | 加热棒输出电压（0~10V） |
| check | uint16 (小端) | SUM_8_O16校验 | 校验和 |
| tail | uint8 | 0x0F | 包尾 |

**协议总长度**: 11字节

---

### 3. 散热风扇协议 (P_Fan)
**用途**: 被测系统输出散热风扇控制指令

| 字段 | 类型 | 值/计算方式 | 说明 |
|------|------|------------|------|
| header | uint16 (大端) | 0xFFFA | 包头 |
| datatype1 | uint8 | 0x02 | 数据类型1 |
| datatype2 | uint8 | 0x22 | 数据类型2 |
| datalen | uint8 | 0x01 | 数据长度（1字节） |
| cmd | uint8 | 0/1 | 操作指令（0=停止，1=启动） |
| check | uint16 (小端) | SUM_8_O16校验 | 校验和 |
| tail | uint8 | 0x0F | 包尾 |

**协议总长度**: 8字节

---

## 🔌 仿真环境配置

### 通道绑定
```json
{
  "Sensor": {
    "type": "serial_232",
    "baudrate": 115200,
    "bind": "SERIAL::S232::0",
    "memo": "温度传感器"
  },
  "Fan": {
    "type": "serial_232",
    "baudrate": 115200,
    "bind": "SERIAL::S232::1",
    "memo": "散热风扇"
  },
  "Heater": {
    "type": "serial_232",
    "baudrate": 115200,
    "bind": "MOCKER::S232::1",
    "memo": "加热棒（模拟通道）"
  }
}
```

---

## 📝 测试脚本编写模式

### 基本结构
```lua
-- 可选：引入辅助模块
require("e_checker")

-- 可选：定义局部变量
local index = 0
local result = {}

-- 必须：定义entry入口函数
function entry()
    -- 测试逻辑
    
    exit()  -- 退出测试
end

-- 可选：定义回调函数
function callback_handler(ch, res)
    -- 处理接收到的数据
end
```

### 核心API汇总

#### 1. 通道操作
```lua
-- 清空通道缓冲区
clear(channels.Sensor)

-- 写入消息（同步）
write_msg(channels.Sensor, protocols.P_Sensor, {temprature = 20})

-- 写入消息（同步等待）
write_msg_sync(channels.Sensor, protocols.P_Sensor, {temprature = 20})

-- 读取缓冲区（timeout单位：毫秒）
res = read_buff(channels.Heater, 0, 1000)

-- 注册接收回调
on_buff_recv(channels.Fan, function(ch, res)
    -- 处理数据
end)

-- 取消接收回调
off_recv(channels.Fan)
```

#### 2. 协议操作
```lua
-- 打包数据
data = pack(protocols.P_Fan, {cmd = 1})

-- 解包数据
pkg = unpack(protocols.P_Heater, ebuff.from_buff(data), true)
if pkg then
    voltage = pkg.value.voltage
    header = pkg.value.header
end
```

#### 3. 校验计算
```lua
require("e_checker")

-- SUM_8校验：从offset开始的bitCount位
checkVal = e_checker.SUM_8(ebuff.from_buff(data), offset, bitCount)
```

#### 4. 测试断言
```lua
-- 检查断言
check(condition, "成功信息", "失败信息")

-- 测试步骤
step("步骤描述", "期望输出", "实际输出", condition)
```

#### 5. 用户交互
```lua
-- 弹窗询问
passed = ask('yesno', {
    title = '提示', 
    msg = '观察界面采集温度是否为11', 
    default = true
})
```

#### 6. 定时器
```lua
-- 延时（毫秒）
etimer.delay(1000)

-- 获取当前时间戳
time = etimer.now()
```

#### 7. 数据驱动
```lua
-- 从YAML加载数据
for idx, value in ipairs(test_data.Frames) do
    print(value.temprature)
end
```

---

## 📊 测试数据格式（YAML）

### 示例1: 数组格式
```yaml
Frames:
     - temprature: -21
       expect: -20
     - temprature: -10
       expect: -10
     - temprature: 0
       expect: 0
     - temprature: 20
       expect: 20
```

### 示例2: 键值对格式
```yaml
# 设置当前温度为10℃
temprature1: 7
temprature2: 7
temprature3: 7
expect: 0
```

---

## ⚙️ 执行配置文件（.run）

每个测试用例需要一个`.run`配置文件，关联：
- 仿真环境（envValue）
- 测试脚本（luaVal）
- 测试数据（yamlVal/netvar）
- 协议文件（protocolList）

```json
{
    "version": 4,
    "data": {
        "envValue": "仿真环境.env",
        "netvar": "测试数据/01_温度采集处理.yml",
        "deviceList": [
            {
                "id": "xxx",
                "name": "仿真设备(脚本)",
                "luaVal": "测试脚本/01_温度采集处理.lua",
                "yamlVal": "测试数据/01_温度采集处理.yml",
                "kind": "SIMU"
            }
        ],
        "protocolList": [
            {"name": "P_Sensor", "uri": "协议/P_Sensor.prot", "checked": true},
            {"name": "P_Heater", "uri": "协议/P_Heater.prot", "checked": true},
            {"name": "P_Fan", "uri": "协议/P_Fan.prot", "checked": true}
        ]
    }
}
```

---

## 🧪 测试用例清单

| 编号 | 脚本文件 | 测试内容 | 需求编号 |
|------|---------|---------|---------|
| 01 | 01_温度采集处理.lua | 温度采集边界处理测试 | 2.3 |
| 02 | 02_接口_加热棒输出.lua | 加热棒输出接口协议测试 | 3.2 |
| 03 | 03_散热风散输出.lua | 散热风扇连续3次检测逻辑 | 2.5 |
| 04 | 04_接口温度传感器输入.lua | 温度传感器输入接口校验 | 3.1 |
| 05 | 05_性能_温控稳定时间性能需求_1.lua | 温控稳定时间性能测试 | 性能需求 |
| 06 | 06_系统循环控制.lua | 1.2秒循环控制测试 | 2.2 |
| 07 | 07_加热棒输出.lua | 加热棒PID输出电压测试 | 2.4 |
| 08 | 08_接口散热风扇输出.lua | 散热风扇输出接口协议测试 | 3.3 |
| 11 | 11_测试1边界值测试.lua | 边界值全面测试 | 综合 |
| 12 | 12_测试2.lua | 简单温度输入测试 | 综合 |
| 13 | 13_测试3.lua | 数据类型1错误测试 | 3.1 |

---

## 🐛 发现的问题清单（根据问题报告模板）

### 问题1: 散热风扇初始状态错误
- **需求编号**: 2.1
- **测试用例**: 系统启动，测试散热风扇初始状态是否为停止状态
- **输入**: 启动温度控制器，观察散热风扇的初始状态情况
- **预期输出**: 温度控制器中散热风扇初始状态为停止状态
- **实际输出**: 温度控制器中散热风扇初始状态为开启状态
- **问题描述**: 散热风扇的初始状态为开启状态，不是停止状态

### 问题2: 循环控制时间间隔不准确
- **需求编号**: 2.2
- **测试用例**: 测试温度控制器是否以1.2秒(误差小于3%)为间隔循环进行采集温度和输出加热棒信号和散热风扇控制信号
- **输入**: 连续输入多个温度信息如-20，-15，-10,0,10，15,25,35,45,50等，观察输出的控制指令
- **预期输出**: 温度控制器以1.2秒为间隔循环进行采集温度和输出
- **实际输出**: 输出指令时间间隔不是1.2S且误差大于3%
- **问题描述**: 温度控制器输出指令时间间隔不是1.2S且误差大于3%

### 问题3: 温度下边界未截断
- **需求编号**: 2.3
- **测试用例**: 测试温度控制器的温度采集和处理功能能否对下边界进行截断处理
- **输入**: 输入温度-21度和-22度
- **预期输出**: 显示输入的温度为-20度
- **实际输出**: 显示输入的温度为-21度和-22度
- **问题描述**: 温度控制器的温度采集处理功能未对超出下边界的温度值进行截断处理

### 问题4: 散热风扇连续检测逻辑错误
- **需求编号**: 2.5
- **测试用例**: 测试当温度控制器连续检测不足3次且当前温度小于等于设定温度时，散热风扇是否停止转动
- **输入**: 在温度控制器中设定温度为10度，且当前散热风扇为开始状态下，输入一次10度，再输入两次11度或12度
- **预期输出**: 当前散热风扇为开始状态
- **实际输出**: 当前散热风扇为停止状态
- **问题描述**: 检测到1次当前温度小于等于设定的温度时，散热风扇停止转动

### 问题5: 数据类型1错误时未丢包
- **需求编号**: 3.1
- **测试用例**: 当界面采集温度不等于11度时，测试温度传感器输入接口处理是否正确，当输入的数据包的"数据类型1"错误时，软件是否采取丢包处理
- **输入**: 输入的数据包的"数据类型1"错误，校验位正确
- **预期输出**: 温度控制器中不显示采集到数据，软件做丢包处理
- **实际输出**: 温度控制器中显示到采集的数据
- **问题描述**: 测试温度传感器输入接口处理是否正确时，当输入的数据包的"数据类型1"错误时，软件没有采取丢包处理

### 问题6: 加热棒输出数据类型2字段错误
- **需求编号**: 3.2
- **测试用例**: 当界面采集温度不等于11度时，测试温度控制器中加热棒输出接口输出数据的"数据类型2"字段是否正确
- **输入**: 输入温度传感器数据并读取加热棒输出数据
- **预期输出**: 输出的"数据类型2"字段为0x11
- **实际输出**: 输出的"数据类型2"字段为0x10
- **问题描述**: 温度控制器的加热棒输出接口输出数据的"数据长度"字段输出出现错误

### 问题7: 散热风扇输出校验字段字节序错误
- **需求编号**: 3.3
- **测试用例**: 当界面采集温度不等于11度时，测试温度控制器中散热风扇输出接口的校验字段是否正确
- **输入**: 输入温度传感器数据并读取散热风扇输出数据
- **预期输出**: 输出的校验字段值为小端字节序
- **实际输出**: 输出的校验字段为大端字节序
- **问题描述**: 温度控制器的散热风扇输出接口的校验字段输出的值出现错误

### 问题8: 加热棒输出电压值计算错误
- **需求编号**: 2.4
- **测试用例**: 测试在温度控制器给定温度时，加热棒5次的输出电压值
- **输入**: 在温度控制器中设定温度为10度，温度控制器计算当前时刻输出的电压值
- **预期输出**: 根据计算得出当前输出时刻的电压值
- **实际输出**: 当前输出时刻的电压值计算错误
- **问题描述**: 在温度控制器中设定温度加热棒输出功能输出的电压值不对

---

## 📐 PID控制算法分析

根据测试脚本07_加热棒输出.lua，可以推断出PID算法实现：

```lua
-- 增量式PID公式
function Volt(j, arr)
    local DP = 0.05  -- 比例系数
    local DI = 0.1   -- 积分系数
    local Dd = 0.1   -- 微分系数
    
    local ek = Td - arr[j]           -- 当前误差
    local ek1 = Td - arr[j-1]        -- 上一次误差
    local ek2 = Td - arr[j-2]        -- 上上次误差
    
    -- 增量式PID
    V = DP * (ek - ek1) + DI * ek + Dd * (ek - 2*ek1 + ek2)
    
    return V
end
```

**测试数据**:
```lua
T = {2.81, 50, 9.1, 5, 1.6}  -- 输入温度序列
Td = 10                       -- 设定温度
```

---

## 🌡️ 恒温箱温度变化模型

根据性能测试脚本05_性能_温控稳定时间性能需求_1.lua：

```lua
Tc = 10     -- 设定温度
T0 = 0      -- 初始外部温度
T = T0      -- 当前温度
V = 0       -- 加热棒输出电压
Fs = 0      -- 散热风扇状态 (0=停止, 2=开启)

-- 每个周期（1.2秒）更新温度
Qi = V * V * 0.2              -- 加热输入
Qo = 0.1 * (T - T0) + Fs      -- 散热输出
T = T + (Qi - Qo)             -- 温度变化

-- 稳定判断：连续10次|T-Tc|<1，则认为稳定
if math.abs(T - Tc) < 1 then
    n = n + 1
else
    n = 0
end

if n >= 10 then
    -- 稳定，记录时间
end
```

**性能要求**: 稳定时间 ≤ 60秒

---

## ✅ 测试要点总结

### 功能测试
1. ✅ 温度采集范围：-20℃ ~ 50℃，超出截断
2. ✅ 加热棒电压范围：0V ~ 10V
3. ✅ 散热风扇状态：0（停止）、1（启动）
4. ✅ 循环控制周期：1.2秒 ± 3%

### 接口测试
1. ✅ 协议包头、包尾正确性
2. ✅ 数据类型字段正确性
3. ✅ 数据长度字段正确性
4. ✅ 校验和计算正确性（SUM_8_O16）
5. ✅ 字节序正确性（大端/小端）
6. ✅ 错误数据包的丢包处理

### 逻辑测试
1. ✅ 初始状态正确性
2. ✅ PID控制算法正确性
3. ✅ 散热风扇连续3次检测逻辑
4. ✅ 边界值处理

### 性能测试
1. ✅ 温控稳定时间 ≤ 60秒

---

## 🎯 编写新测试用例的步骤

### Step 1: 创建协议文件（如果需要新协议）
```json
{
    "version": 4,
    "data": {
        "kind": "protocol",
        "alignment": "right",
        "title": "协议名称",
        "items": [
            {
                "id": "uniqueID",
                "kind": "seg_integer|seg_real",
                "name": "字段名",
                "title": "字段描述",
                "autoValue": "默认值或公式",
                "signed": "true|false",
                "bitCount": "位数",
                "bigOrder": "true|false",
                "encode": "complement"
            }
        ]
    }
}
```

### Step 2: 创建测试脚本（.lua）
```lua
-- 1. 引入必要模块
require("e_checker")

-- 2. 定义变量
local test_result = {}

-- 3. 定义回调函数（如果需要）
function on_receive_data(ch, res)
    local pkg = unpack(protocols.P_XXX, res.value, true)
    if pkg then
        -- 处理数据
    end
end

-- 4. 主测试函数
function entry()
    -- 4.1 初始化
    clear(channels.XXX)
    
    -- 4.2 注册回调（如果需要异步接收）
    on_buff_recv(channels.XXX, on_receive_data)
    
    -- 4.3 执行测试逻辑
    for idx, value in ipairs(test_data.Items) do
        -- 发送数据
        write_msg(channels.Sensor, protocols.P_Sensor, {
            temprature = value.temp
        })
        
        -- 读取响应
        local res = read_buff(channels.Heater, 0, 1000)
        local pkg = unpack(protocols.P_Heater, ebuff.from_buff(res.value), true)
        
        -- 验证结果
        if pkg then
            check(pkg.value.voltage == value.expect, 
                  "电压值正确", 
                  "电压值错误")
        end
        
        etimer.delay(1000)
    end
    
    -- 4.4 取消回调
    off_recv(channels.XXX)
    
    -- 4.5 退出测试
    exit()
end
```

### Step 3: 创建测试数据（.yml）
```yaml
Items:
  - temp: 5
    expect: 0.5
  - temp: 10
    expect: 1.0
  - temp: 15
    expect: 1.5
```

### Step 4: 创建执行配置（.run）
```json
{
    "version": 4,
    "data": {
        "envValue": "仿真环境.env",
        "netvar": "测试数据/XX_测试名称.yml",
        "deviceList": [
            {
                "id": "生成唯一ID",
                "name": "仿真设备(脚本)",
                "luaVal": "测试脚本/XX_测试名称.lua",
                "yamlVal": "测试数据/XX_测试名称.yml",
                "kind": "SIMU"
            }
        ],
        "channelList": [
            {
                "id": "生成唯一ID",
                "name": "仿真设备(脚本)",
                "items": [
                    {"name": "Sensor", "checked": false},
                    {"name": "Fan", "checked": false},
                    {"name": "Heater", "checked": false}
                ]
            }
        ],
        "protocolList": [
            {"name": "P_Sensor", "uri": "协议/P_Sensor.prot", "checked": true},
            {"name": "P_Heater", "uri": "协议/P_Heater.prot", "checked": true},
            {"name": "P_Fan", "uri": "协议/P_Fan.prot", "checked": true}
        ]
    }
}
```

### Step 5: 执行测试并记录问题
在Excel问题报告模板中记录：
- 需求编号
- 测试用例描述
- 输入
- 预期输出
- 实际输出
- 问题描述
- 备注

---

## 💡 关键技巧与注意事项

### 1. 协议校验和计算
```lua
require("e_checker")

-- SUM_8_O16: 8位累加和，输出16位
-- 参数: (数据缓冲区, 起始字节偏移, 校验位数)
local checkVal = e_checker.SUM_8(ebuff.from_buff(data), 3, 56)
```

### 2. 字节序处理
- **大端序 (bigOrder: true)**: 高位字节在前，常用于包头
- **小端序 (bigOrder: false)**: 低位字节在前，常用于数据字段

### 3. 定时与同步
```lua
-- 场景1: 发送后立即继续
write_msg(channels.Sensor, protocols.P_Sensor, data)

-- 场景2: 发送后等待确认
write_msg_sync(channels.Sensor, protocols.P_Sensor, data)

-- 场景3: 精确延时
etimer.delay(1000)  -- 延时1秒
```

### 4. 异步接收模式
```lua
-- 注册回调，后台持续接收
on_buff_recv(channels.Fan, function(ch, res)
    -- 每次收到数据时触发
    local pkg = unpack(protocols.P_Fan, res.value, true)
    if pkg then
        print("收到风扇指令:", pkg.value.cmd)
    end
end)

-- 记得在测试结束前取消回调
off_recv(channels.Fan)
```

### 5. 数据驱动测试
```lua
-- 从YAML加载数据
for idx, value in ipairs(test_data.Frames) do
    print(value.temprature, value.expect)
end

-- 访问单个字段
print(test_data.temprature1)
```

### 6. 条件判断与断言
```lua
-- check: 断言，失败记录但继续执行
check(condition, "成功信息", "失败信息")

-- step: 测试步骤，记录详细信息
local res = step("步骤描述", "期望", "实际", condition)

-- 弹窗询问（用于需要人工观察的测试）
local passed = ask('yesno', {
    title = '提示',
    msg = '观察界面是否显示11度',
    default = true
})
```

---

## 📚 参考资料

1. **CST2024嵌入式分赛--省赛--需求文档.pdf** - 详细需求说明
2. **CST2024嵌入式分赛--省赛--测试要求.pdf** - 测试标准与要求
3. **CST2024嵌入式分赛--省赛--评分规则.pdf** - 评分细则
4. **CST2024嵌入式分赛--问题报告模板.xlsx** - 问题记录模板

---

## 🎓 总结

这个项目展示了一个完整的**嵌入式系统测试工程**实践：

### 核心要素
1. **明确的通信协议** - 规范的二进制协议设计
2. **模块化的测试脚本** - 每个测试用例独立可复用
3. **数据驱动测试** - 测试逻辑与测试数据分离
4. **配置化执行** - 灵活的测试环境配置
5. **完整的问题追踪** - 结构化的问题报告

### 技术栈
- **测试框架**: 基于Lua脚本的自动化测试框架
- **通信协议**: 自定义二进制协议（JSON配置）
- **数据格式**: YAML数据驱动
- **执行配置**: JSON格式的运行配置
- **问题跟踪**: Excel表格

### 测试方法
- 黑盒测试：基于需求规格的功能验证
- 接口测试：协议一致性与字段正确性验证
- 边界值测试：输入范围边界处理验证
- 性能测试：时序与响应时间验证
- 集成测试：多组件协同工作验证

---

**分析日期**: 2024-11-14  
**分析人**: AI助手  
**版本**: 1.0
